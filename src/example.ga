`GAMPIL PROGRAMMING LANGUAGE`

NoneType main[list(str) args]:

    printn ["Hello World!"]		\ function call for 'Hello World!'

    int x; x be 3			\ use ';' for one line
    list(int) num be list [{1, 2, 3}]	\ normal variables

    rax y; y be 7			\ stored at register rax
    st(0) num2 be 8.76			\ stored at FPU register stack 0

    table letter be {"a", "b"}		\ table type
    \ normal tables are static, do not need strict element.. so it can declare even static hashtables!
    \ element types inside normal tables are being optionally inferenced and stored in stack 
    table Hashy be {table(asc8) id be "001", table(asc8) name be "John", num16 age be 0, 7, 9}
    table counts be {nil} * 10		\ all elements set to nil

    \ dynamic table uses 'row' or 'col' function to create tables in heap.. 'col' only returns an address
    \ the 'row' one converts any array types: tables, pylist, ect. into dynamic table with metadata! later in loops
    table let2 be col[, {"c", "d"}]	\ dynamic table types
    table let3 be row[letter]
    table(num16) ptr be num16.adr[x]	\ pointer type + casting

    let2 be col[src be let2, {"e"}]	\ realloc to add 'e' with default arg 'src'
    printf ["element: %d", letter(0)]	\ table indexing
    printf ["keyval: %d", Hashy.age]	\ hash table key value
    printf ["value: %d", ptr(0)]	\ either pointer type considered an array too!

    printf ["added: %d", add[y,b be x]]	\ calling declared function
    printf ["added: %d", add[y, ]]	\ pre-initialized variable can be skipped

    \ if statements
    if x > 5:
           printn ["Higher than 5"]	\ first condition, use 'but' to end block
         but
       x = 5:
           printn ["Equal to 5"]	\ second condition
         but
       x <= 5:
           printn ["Less than 5"]	\ if both second and third true, execution would be parallel
         but				\ these are called 'parallel guard branching'

    `
       parallel guard branching is inspired 
       by Djikstra's Guard Command Language 
    `

       else and x >= 5:
           printn ["Exclusion found!"]	\ use 'else' followed by 'and' keyword to prevent these
         but
      ok

     ` need loops! we invented 'redo' loop! `

    redo letter as int i:
        printn ["Looping"]		\ looping exact 3 times (only static tables or runtime tables are valid)
      ok

    redo row[num] quite as int j:
        printn ["Looping"]		\ looping 3 times
        stop				\ but it can stops ('row' function converts 'num' from list into runtime table)
      ok

    redo:
        if not x >= 0: 			\ loops forever until x less than 0
            stop
          but ok
        x -be 1				\ decrementing x
      ok

    ` 
       the block 'redo: if not x >= 0: stop; but ok ...' can be replaced by
       'redo: while x >= 0; ...' for more conveinence.
    `

    redo: while x < 5			\ preprocessor will convert it into 'redo: if not x < 5: stop;...'
        x be x + 1
      ok

    `
      loops are inspired by BlooP and FlooP
      by Douglas Hofstadter
    `

  ok					\ keyword 'ok' to end blocks


int add[rax a, int b be 0]:
    return a + b			\ returning value to function
  ok

bitOff greet[]:
    print ["Greetings!"]		\ no return type
  ok

` portable types:

   There are bits (bitOff/bitOn), encodings (enc), numbers (num) and rational numbers (rat).

   bit<On or Off>	: length 0 (bitOff) or 1 (bitOn) bit, 0 for void type
   asc<size>		: length <size> bit
      size can be 8 to 32 exponentially, unsigned (asc8, asc16, asc32)
   num<size>		: length <size> bit
      size can be 16 to 64 exponentially, but signed (num16, num32, num64)
   rat<size>		: length <size> bit
      size can be 32 to 128 exponentially (rat32, rat64, rat128)
   table(<type>)	: array type (sizes and types are inferenced)

`

       


   

