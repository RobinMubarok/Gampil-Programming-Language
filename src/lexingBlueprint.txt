-- Keywords

be
if
but
else
ok
and
or
not
redo
quite
as
while
return
nil
true
false

-- Comments

singleComment [\\].*
multiComment [`][^`]*[`] 
Source from https://stackoverflow.com/questions/25395251/detecting-and-skipping-line-comments-with-flex

-- Symbols

assignment ({arithmeticOperator}|{bitwiseOperator})"be"
arithmeticOperator [+\-*/%^]
relationalOperator [<>][=]?|"!="|"="
bitwiseOperator [&|]|"||"|">>"|"<<"
unaryOperator [~!]
iden [_A-Za-z]+[_A-Za-z0-9]*
whole [0-9]+

-- Variable Declaration

varStmt: varDec 
       | varTyp
       | varMult 
       | varTyps 
       | varAssign 

-- declarations only
varMult: varTyps be expr	
       | varTyps be args
       | varTyp be args
varAssign: iden (be|assignment) expr

-- versatile
varTyps: varTys varTyp
varTys: varTyp ',' varTys
varDecs: varDecl varDec
       | varDecl varTyp
varDecl: varDec ',' varDecl
       | varTyp ',' varDecl
varDec: varTyp be expr
varTyp: iden iden
      | advType iden
advType: arrType
       | expr
       | regType
arrType: iden '*'
regType: <depended by architecture>


-- Generals

block: ':' stmt ok
args: arg expr
    | arg
arg: expr ',' arg
   | ',' arg
compstmt: varStmt
        | funcCall
        | whileLine
        | ret
blocstmt: ifStmt
       | loop
stmt: compStmt (';'|'\n') stmt
    | blocStmt stmt
expr: iden
    | table
    | atom
    | funcCall
    | indexTab
    | atrribTab
    | operations
atom: num
    | asc
    | bit
    | nil

-- Function Declaration

funcDec: iden decFunc block
       | advType decFunc block
decFunc: iden '[' (varDec|varTyp|varDecs) ']'
ret: return expr

-- Funtion Call

funcCall: expr '[' (expr|args|varAssign) ']'
        | iden '[' (expr|args|varAssign) ']'

-- If-Else Statement

ifStmt: if {cases}+ ok
ifTern: if {ternCase}+ ok
cases: expr caseBlock
ternCase: expr ':' expr but
caseBlock: ':' stmt but


-- Looping

loop: loopInfo block
loopInfo: redo
        | redo each
        | redo quiteEach
each: iden as (varTyp|varTyps)
    | table as (varTyp|varTyps)
quiteEach: iden quite as (varTyp|varTyps)
         | table quite as (varTyp|varTyps)
whileLine: while atom

-- arrays

table: '{' (element|elements) '}'
elements: repeatElm element
        | repeatElm
repeatElm: element ',' repeatElm
         | ',' repeatElm
element: expr|varDec|varTyp
indexTab: iden '(' expr ')'
atrribTab: iden '.' expr

-- number
num: intNum | floatNum | complexNum
complexNum:
          | signedFloat '+' imagNum 
          | signedFloat '-' imagNum  
signed_number:
             | intPart
             | '-' intPart 
signedFloat:
           | floatPart
           | '-' floatPart
imagNum:
       | imagPart
numPart: intPart | floatPart | imagPart
imagPart: (floatPart | digitPart) ('j' | 'J')
floatPart:
         | digitPart '.' {digitPart}? {exponent}?
         | '.' digitPart {exponent}?
         | digitPart exponent
digitPart: whole ([_]? whole)*
exponent:  ('e' | 'E') ['+' | '-'] digitPart
intPart: decimal | binary | octal | hexDec | zeroInt
decimal: natural ([_]? whole)*
binary: '0' ('b'| 'B') ([_]? binDigit)+
octal: '0' ('o' | 'O') ([_]? octDigit)+
hexDec: '0' ('x' | 'X') ([_]? hexDigit)+
zeroint: '0'+ ([_]? '0')*
natural: [1-9]
binDigit: '0' | '1'
octDigit: [0-7]
hexDigit: whole | [a-f] | [A-F]

-- string
asc: string | ftString
string: {stringPrefix}? (stringContent)
stringPrefix: ([rub]|[RUB])|([Bb][Rr])|([Rr][Bb])
stringContent:
             | "\'\'\'" ( ^"\'\'\'" longStringItem)* "\'\'\'"
             | "\"\"\"" ( ^"\"\"\"" longStringItem)* "\"\"\""
             | [\'] ( ^[\'] stringItem)* [\']
             | [\"] ( ^[\"] stringItem)* [\"]
stringItem: stringChar | stringEscapeseq
stringChar: ^{backslash}|^{newline}
longStringItem:  stringItem | newline
stringEscapeseq: '\' sourceCharacters
sourceCharacters: [\\\'\"abfnrtv]|"ooo"|"xhh"|"N" iden|"uxxxx"|"Uxxxxxxxx"
ftString: ftStart {ftMiddle}* ftEnd
        | ftTripString
ftTripString: ftTripStart {ftMiddlePlus}* ftTripEnd
ftStart: fstringprefix [\'\"]
ftTripStart: fstringprefix ("\'\'\'" | "\"\"\"")
ftEnd: [\'\"]
ftTripEnd: "\'\'\'" | "\"\"\""
fstringprefix: [Ff]|[Tt]|([Ff]|[Tt])[Rr]|[Rr]([Ff]|[Tt])
ftDebugSpecifier: be
ftMiddlePlus:
            | ftMiddle
            | [\n]
ftMiddle:
        | ftReplace
        | ftMid
ftMid:
     | ([^\\] [^\n] [^{] [^}] ^ftQuote) sourceCharacters
     | stringEscapeseq
     | "{{"
     | "}}"
ftReplace: 
         | '{' expr {ftDebugSpecifier}? {ftStringConversion}? {ftStringFullFormat}? '}'
         | table
ftStringConversion:
                  | [!] [sra]
ftStringFullFormat:
                  | ':' {ftStringFormat}*
ftStringFormat:
              | ftMiddle
              | ftReplace


-- operation
operations: logicOr|logicAnd|inclusOr|exclusOr|andOp|eqOp|relatOp|shiftOp|addOp|multiOp|unaryOp|primaryOp|ifTern
logicOr: logicAnd
       | logicalOr or logicAnd
logicAnd: inclusOr
        | logicAnd and inclusOr
inclusOr: exclusOr
        | inclusOr '|' exclusOr
exclusOr: andOp
        | exclusOr "||" andOp
andOp: eqOp
     | andOp '&' eqOp
eqOp: relatOp
    | eqOp '=' relatOp
    | eqOp "!=" relatOp
relatOp: shiftOp
       | relatOp '<' shiftOp
       | relatOp '>' shiftOp
       | relatOp "<=" shiftOp
       | relatOp ">=" shiftOp
shiftOp: addOp
       | shiftOp "<<" addOp
       | shiftOp ">>" addOp
addOp: multiOp
     | addOp '+' multiOp
     | addOp '-' multiOp
multiOp: multiOp '*' expOp
       | multiOp '/' expOp
       | multiOp '%' expOp
expOp: expOp '^' (unaryOp|primaryOp)
unaryOp: not expr
primaryOp: iden
         | asc
         | '(' expr ')'

-- boolean
bit: true|false